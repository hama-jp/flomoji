# 要件定義書: cronトリガーノードによる自律的ワークフロー

## 1. 背景と目的

現状のワークフローは、ユーザーが手動で実行を開始する必要がある。しかし、多くの実用的なユースケース（例: 定期的なWebサイトの監視、日次でのデータ収集、定時レポートの生成など）では、スケジュールに基づいてワークフローを自動実行する機能が不可欠である。

本要件は、指定したスケジュールに基づいてワークフローを自動的に開始する「スケジュールトリガー」ノードを新たに導入し、アプリケーションの自律性を高めることを目的とする。これにより、アプリケーションの用途を大幅に拡大することが期待される。

## 2. スコープ

本ドキュメントは、cronトリガー機能の**設計**を定義するものであり、具体的な実装作業は含まない。

- **スコープ内**:
    - 機能要件の定義
    - システムアーキテクチャの設計
    - データフローの定義
    - 利用技術の選定
- **スコープ外**:
    - 上記機能のプログラミング、テスト、デプロイ

## 3. 機能要件

### 3.1. 概要
ワークフローの開始点として機能する、新しい「スケジュールトリガー」ノード (`type: 'schedule'`) を追加する。このノードは他のノードからの入力を受け付けず、設定されたスケジュールに基づいてワークフローを起動する。

### 3.2. 解決策
アプリケーションはクライアントサイド（ブラウザ内）で完結しているため、サーバーサイドのcronデーモンのような永続的なプロセスは利用できない。この制約のもと、以下のクライアントサイド完結型アーキテクチャを採用する。

1.  **`SchedulerService` の新設**: アプリケーション全体のスケジュールを管理するシングルトンサービスを導入する。
2.  **`croner` ライブラリの利用**: cron式の解析とタイマー実行のために、堅牢で軽量な `croner` ライブラリを利用する。
3.  **`NodeExecutionService` の拡張**: 既存のワークフロー実行エンジンを改修し、`SchedulerService` からの起動に対応させる。

### 3.3. ノード設定項目 (UI)
スケジュールトリガーノードの設定パネルには、以下の項目を含める。

-   **Cron式**: `* * * * *` のような標準的なcron形式で実行スケジュールを入力するフィールド。簡易的なプリセット（例: 毎時、毎日、毎週）も提供し、ユーザーの利便性を高める。
-   **タイムゾーン**: スケジュールを実行するタイムゾーンを選択するドロップダウンリスト。デフォルトはユーザーのブラウザのタイムゾーンとする。
-   **出力ペイロード (オプション)**: スケジュールが発火した際に、後続のノードに渡すJSON形式のデータ。`{"trigger_time": "{{timestamp}}", "message": "Daily report started."}` のように、予約済みの変数（`{{timestamp}}`など）を埋め込める動的ペイロード機能をサポートする。

### 3.4. UI/UX
-   ワークフロー編集画面において、ワークフローに「スケジュールトリガー」ノードが含まれている場合、UIの目立つ位置（例: ヘッダー領域）に「スケジュールを有効化」というトグルスイッチを表示する。
-   ユーザーがこのトグルをONにすると、`SchedulerService` にスケジュールが登録され、タイマーがセットされる。OFFにすると、スケジュールは解除される。

## 4. システムアーキテクチャ

1.  **`SchedulerService.js` (新規作成)**
    -   アプリケーション内に存在する全てのワークフローから「スケジュールトリガー」ノードを能動的にスキャンし、アクティブな（有効化された）スケジュールを一元管理する。
    -   `croner` を利用して、cron式の解析とタイマーの設定を行う。
    -   スケジュールが発火した際、対象のワークフローIDとペイロードを引数に `NodeExecutionService.startExecution` を呼び出し、ワークフローの実行を開始する。

2.  **`NodeExecutionService.js` (修正)**
    -   `executeNode` メソッド内の `switch` 文に `case 'schedule':` を追加する。
    -   このノードの役割は、設定された出力ペイロードを自身の実行結果として後続ノードに渡すことである。`SchedulerService` がワークフロー全体を起動するため、このノード自体が行う処理はシンプルになる。

3.  **関連UIコンポーネント (新規・修正)**
    -   スケジュールトリガーノード専用のReactコンポーネント (`ScheduleNode.jsx` など) を作成し、3.3節で定義した設定項目を実装する。
    -   `WorkflowView.jsx` などの上位コンポーネントを改修し、3.4節で定義した「スケジュール有効化」トグルと `SchedulerService` との連携を実装する。

## 5. 利用技術

-   **スケジューリングライブラリ: [Croner](https://github.com/Hexagon/croner)**
    -   **選定理由**: 軽量（依存関係なし）、高機能（cron式、タイムゾーンサポート）、Promiseベースで非同期処理との親和性が高い、ブラウザ環境での動作実績があるため、本要件に最適と判断。

## 6. 非機能要件

-   **パフォーマンス**: スケジュール管理やログ記録処理が、UIの応答性やワークフローの実行速度に顕著な悪影響を与えないこと。
-   **制約とユーザーへの周知**:
    -   **最重要**: 本機能は、**アプリケーションが動作しているブラウザのタブが開かれている間のみ有効**である。タブが閉じられたり、ブラウザが終了したりすると、スケジュールされたタスクは実行されない。
    -   この制約は、UI上の分かりやすい場所（例: スケジュール有効化トグルの横のツールチップなど）で、ユーザーに明確に通知する必要がある。
-   **将来的な拡張**: Service Worker を利用した、ブラウザタブが閉じていても動作する真のバックグラウンド実行は、実装コストの観点から本バージョンのスコープ外（MVP外）とする。将来的な機能拡張の候補として検討する。

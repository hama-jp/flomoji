# コンポーネント分割リファクタリング提案

## 現状の問題点

### 1. NodeEditor.jsx (864行)
現在最大のコンポーネントで、以下の責任を持っています：
- ワークフロー管理（作成、削除、名前変更）
- ノードの描画とレイアウト
- 接続線の描画
- ドラッグ&ドロップ処理
- 実行制御
- デバッグ機能
- 履歴表示
- インポート/エクスポート

### 2. その他の大きなコンポーネント
- **ChatView.jsx (227行)**: チャット機能と履歴管理
- **SettingsView.jsx (285行)**: 設定画面とバリデーション
- **DataView.jsx (266行)**: データ管理とインポート/エクスポート

## 分割提案

### NodeEditor.jsx の分割案

#### 1. **WorkflowManager** コンポーネント
```
責任: ワークフローの全体管理
- ワークフローの作成/削除/名前変更
- ワークフローリストの管理
- 現在のワークフローの切り替え
```

#### 2. **NodeCanvas** コンポーネント
```
責任: キャンバスの描画とインタラクション
- ノードの描画
- 接続線の描画
- SVG要素の管理
- ズーム/パン機能（将来的に）
```

#### 3. **NodeInteractionHandler** カスタムフック
```
責任: ユーザーインタラクションの処理
- ドラッグ&ドロップ
- ノード選択
- 接続の作成/削除
- コンテキストメニュー
```

#### 4. **WorkflowExecutor** コンポーネント
```
責任: ワークフローの実行制御
- 実行/停止/ステップ実行
- 実行状態の管理
- デバッグログの表示
```

#### 5. **WorkflowToolbar** コンポーネント
```
責任: ツールバーと操作ボタン
- 実行制御ボタン
- インポート/エクスポート
- 表示切り替え
```

#### 6. **NodeTypeSelector** コンポーネント
```
責任: ノードタイプの選択UI
- 利用可能なノードタイプの表示
- ノード追加機能
```

### ChatView.jsx の分割案

#### 1. **MessageList** コンポーネント
```
責任: メッセージの表示
- メッセージリストのレンダリング
- スクロール制御
```

#### 2. **MessageInput** コンポーネント
```
責任: メッセージ入力
- 入力フィールド
- 送信ボタン
- キーボードイベント処理
```

#### 3. **useChatHistory** カスタムフック
```
責任: チャット履歴の管理
- LocalStorageとの同期
- 履歴の読み込み/保存
```

### SettingsView.jsx の分割案

#### 1. **ProviderSettings** コンポーネント
```
責任: プロバイダー固有の設定
- APIキー入力
- エンドポイント設定
- モデル選択
```

#### 2. **ConnectionTester** コンポーネント
```
責任: 接続テスト機能
- テスト実行
- 結果表示
```

#### 3. **SettingsValidation** ユーティリティ
```
責任: 設定値のバリデーション
- 入力値の検証
- エラーメッセージの生成
```

### DataView.jsx の分割案

#### 1. **DataExporter** コンポーネント
```
責任: データのエクスポート
- エクスポート形式の選択
- ファイルダウンロード処理
```

#### 2. **DataImporter** コンポーネント
```
責任: データのインポート
- ファイル選択
- データ検証
- インポート処理
```

#### 3. **StorageManager** コンポーネント
```
責任: ストレージ管理
- 使用量の計算
- データクリア機能
```

## 実装の優先順位

### Phase 1: NodeEditor の分割（高優先度）
1. WorkflowToolbar の分離
2. NodeCanvas の分離
3. WorkflowExecutor の分離
4. NodeInteractionHandler フックの作成

### Phase 2: その他のコンポーネント（中優先度）
1. ChatView の分割
2. SettingsView の分割
3. DataView の分割

### Phase 3: 共通コンポーネントの抽出（低優先度）
1. 共通のフック（useLocalStorage、useDebounce等）
2. 共通のユーティリティ関数
3. 共通のUIパターン

## 期待される効果

### メリット
1. **保守性の向上**: 各コンポーネントの責任が明確になる
2. **テスタビリティの向上**: 小さなユニットでテストが書きやすくなる
3. **再利用性の向上**: 分離したコンポーネントを他の場所でも使える
4. **開発効率の向上**: 複数人での開発時にコンフリクトが減る
5. **パフォーマンスの向上**: 必要な部分だけの再レンダリングが可能
6. **コードの可読性向上**: 各ファイルが小さくなり理解しやすくなる

### デメリット・注意点
1. **ファイル数の増加**: プロジェクト構造が複雑になる可能性
2. **Props drilling**: コンポーネント間のデータ受け渡しが増える
3. **初期の実装コスト**: リファクタリングに時間がかかる
4. **過度な分割のリスク**: 小さすぎる分割は逆に複雑性を増す

## 実装時の注意事項

1. **段階的な移行**: 一度にすべてを変更せず、段階的に進める
2. **テストの追加**: リファクタリング前にテストを書く
3. **状態管理の検討**: Context APIやZustandなどの導入を検討
4. **型定義の追加**: TypeScriptへの移行も視野に入れる
5. **ドキュメント化**: 新しい構造についてのドキュメントを作成

## まとめ

現在のコードベースは機能追加により肥大化しているため、責任の分離を行うことで保守性と拡張性を大幅に改善できます。特にNodeEditor.jsxは緊急度が高く、Phase 1として優先的に取り組むべきです。
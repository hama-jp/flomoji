# FS: cronトリガーノード追加による自律的ワークフローの実現性調査

## 1. はじめに

### 1.1. 目的
本調査は、`idea/idea_05_streaming_data_pipeline.md`で提案されたコンセプトを拡張し、ユーザーからのリクエストを起点とするだけでなく、スケジュール（cron）に基づいて自律的に動作するワークフローを実現するための「cronトリガーノード」の実現可能性を評価することを目的とする。

### 1.2. 背景
現状のLLM Agent Liteのワークフローは、ユーザーが手動で実行を開始する必要がある。これに対し、定期的なデータ収集、監視、レポート生成などのユースケースでは、タイマーによる自動実行機能が求められる。本機能の追加により、アプリケーションの用途が大幅に拡大することが期待される。

## 2. 既存システムの分析

コードベースを調査した結果、ワークフロー実行のコアとなるのは `src/services/nodeExecutionService.js` であることが判明した。

-   **実行モデル**: ワークフローを単なるステップの配列ではなく、有向非巡回グラフ（DAG）として扱っている。`determineExecutionOrder` 関数によりトポロジカルソートを行い、複雑な依存関係を持つノードの実行順序を決定している。
-   **ノードの種類**: `executeNode` メソッド内の `switch` 文で、`input`, `llm`, `if` といった各種ノードの処理を振り分けている。新しいノードタイプを追加するには、ここに新しい `case` を追加するのが適切なアプローチとなる。
-   **実行エンジン**: `startExecution` は非同期イテレータを返し、外部からステップごとに実行を制御できる高度な設計となっている。
-   **制約**: アプリケーションは完全にクライアントサイド（ブラウザ内）で動作する。永続化には `localStorage` を使用しており、サーバーサイドのプロセスは存在しない。この点が、スケジューリング機能の実装における最大の制約となる。

## 3. cronトリガーノードの設計案

### 3.1. 機能要件とUI

新しく「スケジュールトリガー」ノード（`type: 'schedule'`）を追加する。このノードはワークフローの開始点となり、他のノードへの入力は受け付けない。

**ノード設定項目（UI）:**

-   **Cron式**: `* * * * *` のような標準的なcron形式で実行スケジュールを入力。簡易的なプリセット（毎時、毎日など）も提供。
-   **タイムゾーン**: 実行タイムゾーンを選択（デフォルトはブラウザのタイムゾーン）。
-   **出力ペイロード（オプション）**: スケジュールが発火した際に、後続のノードに渡すデータ（JSON形式）。例えば、`{"trigger_time": "{{timestamp}}", "message": "Daily report generation started."}` のように、`{{timestamp}}` などの予約済み変数を埋め込めるようにする。

### 3.2. システムアーキテクチャ

クライアントサイドでのスケジュール管理を実現するため、以下のアーキテクチャを提案する。

1.  **`SchedulerService.js` (新規作成)**:
    *   シングルトンサービスとして実装。
    *   アプリケーション内に存在する全てのワークフローから「スケジュールトリガー」ノードをスキャンし、アクティブなスケジュールを管理する。
    *   `croner` などの堅牢なライブラリを使用し、cron式の解析とタイマーの設定を行う。
    *   スケジュールが発火した際、対象のワークフローIDとペイロードを引数に、`WorkflowManager`（仮の統括サービス）または直接 `NodeExecutionService` を呼び出してワークフローの実行を開始する。

2.  **`NodeExecutionService.js` (修正)**:
    *   `executeNode` に `case 'schedule':` を追加。
    *   このノードは、`SchedulerService` によって実行がトリガーされるため、`executeNode` 内での処理はシンプルになる。基本的には、設定された出力ペイロードを自身の実行結果として返し、後続のノードにデータを渡す役割を担う。

3.  **`WorkflowView.jsx` / 関連UIコンポーネント (修正)**:
    *   ワークフローに「スケジュールトリガー」ノードが含まれている場合、UI上に「スケジュール有効化」のようなトグルスイッチを表示する。
    *   ユーザーがスケジュールを有効化すると、`SchedulerService` にそのワークフローのスケジュールを登録する。無効化した場合は登録を解除する。

### 3.3. データフロー

1.  ユーザーがUI上でワークフローのスケジュールを有効化する。
2.  `SchedulerService` がそのワークフローのcron式をパースし、タイマーをセットする。
3.  指定時刻になると、`croner` がコールバックを発火させる。
4.  `SchedulerService` のコールバック関数は、`NodeExecutionService.startExecution` を呼び出し、該当ワークフローの実行を開始する。
5.  `NodeExecutionService` は、トポロジカルソートに基づき、まず「スケジュールトリガー」ノードを実行する。
6.  「スケジュールトリガー」ノードは、設定されたペイロード（例: 現在時刻）を生成し、自身の出力とする。
7.  後続のノードは、その出力を `{{step1_output}}` のような形で利用し、処理を継続する。

## 4. 使用技術の提案

-   **スケジューリングライブラリ: [Croner](https://github.com/Hexagon/croner)**
    *   **選定理由**:
        *   軽量（依存関係なし）。
        *   cron式とタイムゾーンをサポートしており、高機能。
        *   Promiseベースで非同期処理との親和性が高い。
        *   ブラウザ環境で動作実績がある。
    *   **代替案**: `setInterval` を使った自前実装も可能だが、cron式のパースや夏時間などを考慮すると、ライブラリ利用が堅牢かつ効率的である。

## 5. 実現性の評価

### 5.1. 技術的リスクと課題

-   **クライアントサイド実行の制約**:
    *   **最大の課題**: スケジュールが発火するためには、**アプリケーションのブラウザタブが開いている必要がある**。タブが閉じられると、JavaScriptの実行コンテキストが失われ、タイマーも停止する。
    *   **対策/緩和策**:
        1.  **ユーザーへの明確な説明**: UI上で「この機能はブラウザを開いている間のみ有効です」と明記する。
        2.  **Service Workerの利用（将来的な拡張）**: Service Worker を導入すれば、ブラウザタブが閉じていてもバックグラウンドでタイマーを実行し、Web Push通知などでユーザーに知らせることが可能になる。ただし、これは実装コストが格段に上がるため、最初のバージョン（MVP）の範囲外とするのが妥当。

### 5.2. 実装の概算ステップ

1.  `croner` ライブラリをプロジェクトに追加 (`pnpm add croner`)。
2.  `SchedulerService.js` を新規作成し、スケジュールの登録・解除・発火ロジックを実装。
3.  `NodeExecutionService.js` を修正し、`schedule` ノードタイプに対応。
4.  スケジュールノード用のReactコンポーネント（設定パネルUI）を作成。
5.  `WorkflowView.jsx` を改修し、スケジュール有効化のUIと `SchedulerService` との連携を実装。
6.  ドキュメントを更新し、機能の仕様と制約について記述。

## 6. 結論と提言

**結論**:
cronトリガーノードの追加は、**技術的に実現可能**である。既存の `nodeExecutionService.js` の設計が優れているため、比較的クリーンに新機能を追加できる。

**最大の懸念事項**はクライアントサイド実行に起因する「ブラウザタブを開いている必要がある」という制約だが、これは機能の提供価値を損なうものではなく、ユーザーに仕様を明示することで許容可能と判断する。

**提言**:
本機能はアプリケーションの価値を大きく向上させるため、実装を**推奨**する。
MVP（Minimum Viable Product）としては、Service Worker を含めず、ブラウザタブ内での実行に限定して開発を進めるのが現実的である。将来的な拡張として、より高度なバックグラウンド実行の検討を行うと良い。
